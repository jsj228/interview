git 是如何解决代码冲突的    https://www.cnblogs.com/gavincoder/p/9071959.html
vue 插件大全：https://www.cnblogs.com/jdsm/p/10016793.html
Vue面试题
说说你对 SPA 单页面的理解，它的优缺点分别是什么？
    SPA：仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，
    SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。
    优点：用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
         基于上面一点，SPA 相对对服务器压力小；
         前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；
    缺点：初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
         前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
         SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。
1. 对于MVVM的理解  
     MVVM 是 Model-View-ViewModel 的缩写。
    （1）Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。
    （2）View 代表UI 组件，它负责将数据模型转化成UI 展现出来。
    （3）ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。
    （4）在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 
        因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。
    （5）ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，
        因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。
2.v-model 的原理 
    在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，
    v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：
        text 和 textarea 元素使用 value 属性和 input 事件；   
        checkbox 和 radio 使用 checked 属性和 change 事件；  
        checkbox 和 radio 使用 checked 属性和 change 事件；
3. vue.js的两个核心是什么      数据驱动和组件化
4.Vue实现双向数据绑定
    （1）Vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，
        在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 
        将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。
    （2）vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令，
        最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。
5. Vue组件间的参数传递 （微信收藏）
    （1）父组件向子组件传值：子组件通过props方法接受数据
    （2）子组件向父组件传值：子组件通过  emit() 方法传递参数 ， 父组件通过 emit() 方法传递参数，父组件通过emit()方法传递参数，父组件通过on()监听
    （3）兄弟组件传值：eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。
        https://blog.csdn.net/zhongzk69/article/details/80928170         https://blog.csdn.net/weixin_39944375/article/details/113323828
    （4）跨级传值*：provide/inject  
6. 组件中 data 为什么是函数
    （1）因为组件是用来复用的，JS 里对象是引用关系，这样作用域没有隔离，而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题
7. v-show 与 v-if 区别
    （1）v-show和v-if的区别：v-show是css切换，v-if是完整的销毁和重新创建。
    （2）v-show和v-if的使用：频繁切换时用v-show，运行时较少改变时用v-if
8.v-for 与 v-if 的优先级            v-for的优先级比v-if高
9. vue中 key 值的作用
    （1）使用key来给每个节点做一个唯一标识
    （2）key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。
10. 如何进行vue中的二次渲染
    如果要在组件内部中进行强制刷新，则可以调用 this.$forceUpdate() 强制重新渲染组件，从而达到更新目的。
11.绑定 class 的数组用法
    （1）对象方法 v-bind:class="{‘orange’: isRipe, ‘green’: isNotRipe}"
    （2）数组方法v-bind:class="[class1, class2]"
    （3）行内 v-bind:style="{color: color, fontSize: fontSize+‘px’ }"
12.计算属性computed和 监听watch 的区别
    （1）computed 是一个对象时，它有哪些选项：有get和set两个选项;     计算属性默认只有 getter，不过在需要时你也可以提供一个 setter   (注：computed有缓存，如果不需要缓存可以使用方法函数代替)
    （2）computed 和 watch有什么区别：只是需要动态值，那就用计算属性；需要知道值的改变后执行业务逻辑，才用 watch
    （3）watch 是一个对象时，它有哪些选项：handler，deep 是否深度，immeditate 是否立即执行
13.Vue的生命周期
    （1）什么是vue生命周期：Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期
    （2）Vue的生命周期： beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed
    （3）vue生命周期的作用是什么：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑
    （4）vue生命周期总共有几个阶段：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后
    （5）生命周期详解：
        beforeCreate：（创建前） 在数据观测和初始化事件还未开始
        created：（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来
        beforeMount：（挂载前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。
        mounted：（挂载后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。
            完成模板中的html渲染到html页面中。此过程中进行ajax交互。
        beforeUpdate：（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。
        updated：（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。
            然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。
        activited	keep-alive 专属，组件被激活时调用
        deactivated	keep-alive 专属，组件被销毁时调用
        beforeDestroy：（销毁前） 在实例销毁之前调用。实例仍然完全可用。
        destroyed：（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。
    （6）第一次页面加载会触发哪几个钩子：会触发 下面这几个beforeCreate, created, beforeMount, mounted
    （7）DOM 渲染在 哪个周期中就已经完成：DOM 渲染在 mounted 中就已经完成了
    （8）Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：
        加载渲染过程
        父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted
        子组件更新过程
        父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated
        父组件更新过程
        父 beforeUpdate -> 父 updated
        销毁过程
        父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed
    (9)在哪个生命周期内调用异步请求？
        可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。
        但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：
            能更快获取到服务端数据，减少页面 loading 时间；
            ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；
    (10).在什么阶段才能访问操作DOM？
        在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。 
    (11).父组件可以@hook 来到子组件的生命周期； 
14. Vue的路由实现：hash模式 和 history模式
    （1）hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；
        特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面
    （2）history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）
        可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。history 模式下，
        前端的 URL 必须和实际向后端发起请求的 URL 一致，如http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误
15.vue-router有哪几种路由守卫 （ 配置路由时设置）
    （1）全局守卫（在跳转之前执行 -> 有权限加载选择）： 
        router.beforeEach((to,from,next)=>{if(to.meta.isAuth){next()//调用该方法,才能进入下一个钩子 }else{}})
        https://blog.csdn.net/heshuaicsdn/article/details/88020796    https://www.cnblogs.com/wuvkcyan/p/9311155.html
    （2）后置守卫：（在跳转之后执行 ）：
        router.afterEach((to,from)=>{if(to.meta.isAuth){}else{}}) 
    （3）全局解析守卫：beforeResolve
    （4）路由独享守卫：beforeEnter
16.$route和 $router的区别是什么
    （1）$router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等
    （2）$route 是路由信息对象||跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，包含path,params,hash,query,fullPath,matched,name等路由信息参数
17.vuex有哪几种属性
    （1）有五种，分别是 State、 Getter、Mutation 、Action、 Module。
        State：state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新
        Getter：getters 可以对State进行计算操作，它就是Store的计算属性
        Mutation：有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)
        Action：Action 提交的是 mutation，而不是直接变更状态。
        Module：由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决这个问题，Vuex 允许我们将 store 分割成模块
        原文链接：https://blog.csdn.net/qq_44291585/article/details/118338182
18.vue3和vue2的区别
    vue3新特性：
          1.数据响应重新实现（ES6的proxy代替Es5的Object.defineProperty）
          2.源码使用ts重写，更好的类型推导
          3.虚拟DOM新算法（更快，更小）
          4.提供了composition api，为更好的逻辑复用与代码组织
          5.自定义渲染器（app、小程序、游戏开发）
          6.Fragment，模板可以有多个根元素
    响应原理对比
          1.vue2使用Object.defineProperty方法实现响应式数据
          2.缺点：
            无法检测到对象属性的动态添加和删除
            无法检测到数组的下标和length属性的变更
          3.解决方案：
            vue2提供Vue.$set动态给对象添加属性
            Vue.$delete动态删除对象属性
            重写数组的方法，检测数组变更
　　1.vue3使用proxy实现响应式数据
       优点：  可以检测到代理对象属性的动态新增和删除     可以见到测数组的下标和length属性的变化
       缺点：  es6的proxy不支持低版本浏览器 IE11        回针对IE11出一个特殊版本进行支持
19.Vue之混入和混淆：https://blog.csdn.net/qq_38912284/article/details/103574048
—————————————————————————————————————————————————————————————————————————————— vue页面加载过慢解决 ——————————————————————————————————————————————————
vue页面加载过慢解决
一、vue-router路由懒加载
 1、方法一
    export default new Router({
      routes: [{
          path: '/index',
          component: resolve=>require(['@/components/HelloWorld'],resolve)
        }]
    })
 2、方法二
    export default new Router({
      routes: [{
          path: '/index',
          component: ()=>import('@/components/HelloWorld')
        }]
    })
 3、webpack独有的require.ensure技术，也可以实现按需加载;    
    懒加载是当路由被访问的时候才加载对应组件，而不是在首页就全部加载，以此来提高首页反应速度。
    说明: require.ensure在需要的时候才下载依赖的模块，当参数指定的模块都下载下来了（下载下来的模块还没执行），便执行参数指定的回调函数。require.ensure会创建一个chunk，
    且可以指定该chunk的名称，如果这个chunk名已经存在了，则将本次依赖的模块合并到已经存在的chunk中，最后这个chunk在webpack构建的时候会单独生成一个文件。
    语法: require.ensure(dependencies: String[], callback: function([url]),errorCallback: function(err), [chunkName: String]) 
          dependencies: 依赖的模块数组   
          callback: 成功回调，该函数调用时会传一个require参数     
          errorCallback:错误回调   
          chunkName: 特定模块名，用于构建时生成文件时命名使用， 多个路由指定相同的chunkName，会合并打包成一个js文件。
    import Vue from 'vue'
    import Router from 'vue-router'
    Vue.use(Router) 
    export default new Router({
      routes: [
        {
          path: '/index',
          name: 'Index',
          component: resolve=>require.ensure (['@/components/HelloWorld'],"home")
        },
        {
          path: '/home',
          name: 'home',
          component: resolve=>require.ensure (['@/components/home'],"home")
        }
      ]
    })
    注意点：require.ensure的模块只会被下载下来，不会被执行，只有在回调函数使用require(模块名)后，这个模块才会被执行。
    webpack.base.conf.js修改：https://blog.csdn.net/LSL3521/article/details/105227330
二、打包优化——工程文件打包的时候不生成.map文件
    npm run build编译之后，我们查看编译生成的文件，发现有很多.map文件，这些文件占了不小的空间。
    .map文件的作用是帮助编译后的代码调试，但是我们上线的代码已经调试完成，所以上线时可以不生成.map文件。
    修改配置文件如下即可：productionSourceMap : false 
三、切换多入口模式
    在vue项目中，我们一般使用vue-cli脚手架搭建单页面的web工程。
    main.js是整个单页面应用唯一的入口文件
    在大型项目中，单一入口无法满足项目需要，原因有以下两方面：
    （1）单一入口无法拆分按模块独立部署，不够灵活
    （2）单一入口负载过重，业务模块较多时，点击系统导航菜单频繁切换业务模块，在IE浏览器中，浏览器内存持续上涨，达到 1.5G以上卡顿，浏览器容易崩溃。
    基于以上两点原因，大型项目可以采用多入口的模式，好处有以下两点：
    （1）满足页面需要分开部署的场景            （2）解决了页面卡顿和内存上涨问题
    配置方式参考我的单独讲解多入口配置的博文
四、使用字体图标代替切图
    字体图标的优势:
    （1）字体图标任意缩放不会失真
    （2）在项目中导入后，以css样式引用，相较于传统的图片大大减少请求数量，优化性能
    （3）修改方便，如需要切换主题色可由css控制，避免视觉反复切图的工作量
    在线生成工具: https://icomoon.io/app/#/select
五、使用雪碧图
    雪碧图的优点:
     1.将多张图片合并到一张图片中，可以减小图片的总大小。
     2.将多张图片合并成一张图片后，下载全部所需的资源，只需一次请求。可以减小建立连接的消耗。
六、提取公共样式和方法
    1.复用的样式应当提取到公共的样式表中复用
    2.公共的方法应当提取到公共的js中复用
    3.表单验证的提取    
七、控件销毁
    1.页面切换释放:
    使用的C++控件应当及时销毁
    2. $destroy
    完全销毁一个实例,清理它与其它实例的连接，解绑它的全部指令及事件监听器。
    const testDestroy = new Vue({
        el:'#app',
        data()=>{
            return {
            MsgNotifyParams:{}
        },
        template: "<App :MsgNotifyParams="MsgNotifyParams" /> ",
        compoenents:{App}
    })
    //在即将离开当前页面(刷新或关闭)时执行
    window.onbeforeunload = function (e){
        window.testDestroy.$destroy()
    }
八、定时器销毁
    路由离开及时销毁定时器 
    berforeDestory(){
        let _this=this;
        //清空Timeout定时器
        _this.timerLine && clearTimeout(_this.timerLine);
        _this.timerPie && clearTimeout(_this.timerPie);
        _this.timerBar && clearTimeout(_this.timerBar);
        //页面切换时清空echarts
        myChartLine.clear();
        myChartPie.clear();
        myChartBar.clear();
    }
九、路由离开及时解绑事件:   vm.$off()
十、vue中使用keep-alive
    vue2.0提供了一个keep-alive组件，用来缓存组件,避免多次加载相应的组件,减少性能消耗，  <keep-alive>    <component><!-- 组件将被缓存 --></component>    </keep-alive>
    一般结合路由和动态组件一起使用，用于缓存组件；
    提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
    对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。  
十一、代码层面的优化
    1、v-show，v-if 用哪个？
        （1）只要涉及到权限相关的展示无疑要用 v-if
        （2）在没有权限限制时根据用户点击的频次选择，频繁切换的使用 v-show，不频繁切换的使用 v-if（减少页面中 dom 数量）
    2、不要在模板里面写过多的表达式与判断
        v-if="isShow && isAdmin && (a || b)"，这种表达式虽说可以识别，但是不是长久之计，当看着不舒服时，适当的写到 methods 和 computed 里面封装成一个方法，这样的好处是方便我们在多处判断相同的表达式，其他权限相同的元素再判断展示的时候调用同一个方法即可。
    3、循环调用子组件时添加 key
      key 可以唯一标识一个循环个体，可以使用例如 item.id 作为 key，
      假如数组数据是这样的 ['a' , 'b', 'c', 'a'],使用 :key="item" 显然没有意义，
      更好的办法就是在循环的时候 (item, index) in arr，然后 :key="index"来确保key 的唯一性。不设置key值时vue会抛出警告。
    4、遵守编码规范
        语义化标签，避免乱嵌套，合理命名属性,使用高效简洁的css选择器等等
    5、合理利用vue生命周期
        减少在created生命周期中做ajax请求,而是放在mounted生命周期中,以不阻塞页面生成dom
十二、iframe的内存释放
    相关资料称IE在iframe元素的回收方面存在着bug，需要手动将其释放以避免内存泄漏
    释放方法：手动将iframe指向置空 
    export defaylt {
        name: "windowInspectionRecord",
        methods:{
            clearIframe(){
                var iframe = document.getElementById('windowiframe');
                if(iframe) {
                    iframe.src = "about:blank";
                    try{
                        iframe.document.write('');
                        ifrane.document.clear();
                    }catch(e){}
                    iframe.parentNode.removeChild(iframe);
                }
            }
        },
        beforeRouteLeave ( to,from,next ){
            this.clearIframe()
            next()
        }
    }
