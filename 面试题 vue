git 是如何解决代码冲突的    https://www.cnblogs.com/gavincoder/p/9071959.html
vue 插件大全：https://www.cnblogs.com/jdsm/p/10016793.html
2021 Vue.js 面试题汇总及答案：https://jackniu81.github.io/2021/04/12/Vue-js-Interview-Questions-and-Answers-2021/
vue 调试   https://www.jianshu.com/p/c091cef64fa5    https://blog.csdn.net/xdcx950288/article/details/80640918
Vue面试题  https://www.jianshu.com/p/9f460e66ce01
自定义指令 http://r-beta.hw3static.com/s/publicsaas/uibuilder/docs/lst/vue/v2/guide/custom-directive.html
    说说你对 SPA 单页面的理解，它的优缺点分别是什么？
        SPA：仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，
        SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。
        优点：用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
             基于上面一点，SPA 相对对服务器压力小；
             前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；
        缺点：初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
             前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
             SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

vue中ref的使用 https://blog.csdn.net/weixin_43233914/article/details/108776124
    a.使用ref属性获取元素：
        vue2中：
        <div ref="attr"></div>
        this.$refs.attr.innerText="str"
        vue3中：
    b.使用ref属性在外面的组件上
        <div id="ref-outside-component" v-on:click="consoleRef">    <component-father ref="outsideComponentRef"></component-father>  </div>
        var refoutsidecomponentTem={    template:"<div class='childComp'><h5>我是子组件</h5></div>"   };
        var refoutsidecomponent=new Vue({
            el:"#ref-outside-component",
            components:{   "component-father":refoutsidecomponentTem  },
            methods:{
                consoleRef:function () {
                    console.log(this); // #ref-outside-component    vue实例
                    console.log(this.$refs.outsideComponentRef);  // div.childComp vue实例，组件实例
                }
            }
        });
18.vue3和vue2的底层区别
    vue3新特性：
          1.数据响应重新实现（ES6的proxy代替Es5的Object.defineProperty）
          2.源码使用ts重写，更好的类型推导
          3.虚拟DOM新算法（更快，更小）
          4.提供了composition api，为更好的逻辑复用与代码组织
          5.自定义渲染器（app、小程序、游戏开发）
          6.Fragment，模板可以有多个根元素
    响应原理对比
          1.vue2使用Object.defineProperty方法实现响应式数据
          2.缺点： 无法直接检测到   对象属性的动态添加和删除; 无法检测到  数组的下标和length属性的变更    
          3.解决方案：
            vue2提供Vue.$set动态给对象添加属性
            Vue.$delete动态删除对象属性
            Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听
　　1.vue3使用proxy实现响应式数据
       优点：  可以检测到代理对象属性的动态新增和删除     可以见到测数组的下标和length属性的变化
       缺点：  es6的proxy不支持低版本浏览器 IE11        回针对IE11出一个特殊版本进行支持
   2.vue3是如何实现对象代理proxy的，实现响应式数据（Observe、Complife、Watcher是如何工作的）
    通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，
    达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果

1. 对于MVVM的理解  
     MVVM 是 Model-View-ViewModel 的缩写。
     MVVM原理：通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时，触发相应监听的回调。
     
    （1）Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。
    （2）View 代表UI 组件，它负责将数据模型转化成UI 展现出来。
    （3）ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。
    （4）在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 
        因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。
    （5）ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，
        因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。
2.v-model 的原理 
    在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，
    v-model 本质上不过是v-bind:value和v-on:$event 的语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：
        text 和 textarea 元素使用 value 属性和 input 事件($event)；   
        checkbox 和 radio 使用 checked 属性和 change 事件($event)；  
        checkbox 和 radio 使用 checked 属性和 change 事件($event)；
        // v-model相当于写两件事情
        // 1.:value="user.username"
        // 2.监听组件的事件,获取他的值@input="user.username $event.target.value"这是model等价写法
        //   model默认input是一个元素，event是一个原生event。绑定value等于一个东西，然后@input让东西等于$event.target.value可以实现绑定一个变量，在变量变化的时候，ui变化。
        //  用户改变ui的时候，数据也会变化
3. vue.js的两个核心是什么      数据驱动和组件化
4.Vue实现双向数据绑定
    （1）Vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，
        在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 
        将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。
    （2）vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令，
        最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。
5. Vue组件间的通信 （微信收藏）
    （1）父组件向子组件传值：子组件通过props方法接受数据
    （2）子组件向父组件传值：子组件通过  emit() 方法传递参数 ， 父组件通过 emit() 方法传递参数，父组件通过emit()方法传递参数，父组件通过on()监听
    （3）适用于 父子、隔代、兄弟组件通信：EventBus、vueX 
        EventBus：
            就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。        
            https://blog.csdn.net/zhongzk69/article/details/80928170    https://blog.csdn.net/weixin_39944375/article/details/113323828
    （4）适用于 隔代组件通信 ：provide/inject  
    （5）attrs/listeners 适用于 隔代组件通信
        attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，
               这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。
        listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="listeners" 传入内部组件
6.vueX 有哪几种属性
    （1）有五种，分别是 State、 Getter、Mutation 、Action、 Module。
        State：state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新
        Getter：getters 可以对State进行计算操作，它就是Store的计算属性
        Mutation：有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)
        Action：Action 提交的是 mutation，而不是直接变更状态。
        Module：由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决这个问题，Vuex 允许我们将 store 分割成模块
        原文链接：https://blog.csdn.net/qq_44291585/article/details/118338182
7. v-show 与 v-if 区别
    （1）v-show和v-if的区别：v-show是css切换，v-if是完整的销毁和重新创建。
    （2）v-show和v-if的使用：频繁切换时用v-show，运行时较少改变时用v-if
8.v-for 与 v-if 的优先级            v-for的优先级比v-if高
9. 虚拟DOM，diff算法
（1）让我们不用直接操作DOM元素，只操作数据便可以重新渲染页面
（2）虚拟dom是为了解决浏览器性能问题而被设计出来的;当操作数据时，将改变的dom元素缓存起来，都计算完后再通过比较映射到真实的dom树上
（3）diff算法比较新旧虚拟dom。
    如果节点类型相同，则比较数据，修改数据；如果节点不同，直接干掉节点及所有子节点，插入新的节点；如果给每个节点都设置了唯一的key，就可以准确的找到需要改变的内容，
    否则就会出现修改一个地方导致其他地方都改变的情况。比如A-B-C-D, 我要插入新节点A-B-M-C-D,实际上改变的了C和D。但是设置了key，就可以准确的找到B C并插入
9.1 vue中 key 值的作用
    （1）使用key来给每个节点做一个唯一标识
    （2）key的主要作用：因为vue采用diff算法，为了高效的更新虚拟DOM。
        另外相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。
10. 如何进行vue中的二次渲染
    如果要在组件内部中进行强制刷新，则可以调用 this.$forceUpdate() 强制重新渲染组件，从而达到更新目的。
11.绑定 class 的数组用法
    （1）对象方法 v-bind:class="{‘orange’: isRipe, ‘green’: isNotRipe}"
    （2）数组方法v-bind:class="[class1, class2]"
    （3）行内 v-bind:style="{color: color, fontSize: fontSize+‘px’ }"
12.计算属性computed和 监听watch 的区别
    （1）computed 是一个对象时，它有哪些选项：有get和set两个选项;     计算属性默认只有 getter，不过在需要时你也可以提供一个 setter   (注：computed有缓存，如果不需要缓存可以使用方法函数代替)
    （2）computed 和 watch有什么区别：只是需要动态值，那就用计算属性；需要知道值的改变后执行业务逻辑，才用 watch
    （3）watch 是一个对象时，它有哪些选项：handler，deep 是否深度，immeditate 是否立即执行
13.Vue的生命周期
    （1）什么是vue生命周期：Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期
    （2）Vue的生命周期： beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed
    （3）vue生命周期的作用是什么：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑
    （4）vue生命周期总共有几个阶段：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后
    （5）生命周期详解：
        beforeCreate：（创建前） 在数据观测和初始化事件还未开始
        created：（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来  --> 发送ajax请求 (常用）
        beforeMount：（数据绑定前，挂载前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。
        mounted：（数据绑定后，挂载后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。
            完成模板中的html渲染到html页面中。此过程中进行ajax交互。
        beforeUpdate：（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。
        updated：（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。
            然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。
        activited	keep-alive 专属，组件被激活时调用   <keep-alive>   <router-view></router-view>  </keep-alive>
        deactivated	keep-alive 专属，组件被销毁时调用
        beforeDestroy：（销毁前） 在实例销毁之前调用。实例仍然完全可用。
        destroyed：（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。
    （6）第一次页面加载会触发哪几个钩子：会触发 下面这几个beforeCreate, created, beforeMount, mounted
    （7）DOM 渲染在 哪个周期中就已经完成：DOM 渲染在 mounted 中就已经完成了
    （8）Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：
        加载渲染过程
        父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted
        子组件更新过程
        父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated
        父组件更新过程
        父 beforeUpdate -> 父 updated
        销毁过程
        父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed
    (9)在哪个生命周期内调用异步请求？
        可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。
        但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：
            能更快获取到服务端数据，减少页面 loading 时间；
            ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；
    (10).在什么阶段才能访问操作DOM？mounted 
        在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。 
    (11).父组件可以@hook 来到子组件的生命周期； 

14. Vue的路由实现：hash模式 和 history模式
    （1）hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；
        特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面
        hash 路由模式的实现主要是基于下面几个特性：
        URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
        hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
        可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；
    （2）history模式：history采用HTML5的新特性；且提供了两个新API：pushState()、replaceState（)
        window.history.pushState(null, null, path) 新增一个历史记录 ;
        window.history.replaceState(null, null, path) 是直接替换当前的历史记录
        对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。可以在不进行刷新的情况下，操作浏览器的历史纪录
        history 路由模式的实现主要基于存在下面几个特性：
        我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；history.pushState()或history.replaceState()不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。
        注意：history 模式：前端的 URL 必须和实际向后端发起请求的 URL 一致，如http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误
15.vue-router有哪几种路由守卫 （ 配置路由时设置）
    （1）全局守卫（在跳转之前执行 -> 有权限加载选择）： 
        router.beforeEach((to,from,next)=>{if(to.meta.isAuth){next()//调用该方法,才能进入下一个钩子 }else{}})
        https://blog.csdn.net/heshuaicsdn/article/details/88020796    https://www.cnblogs.com/wuvkcyan/p/9311155.html
    （2）后置守卫：（在跳转之后执行 ）：
        router.afterEach((to,from)=>{if(to.meta.isAuth){}else{}}) 
    （3）全局解析守卫：beforeResolve
    （4）路由独享守卫：beforeEnter
16.$route和 $router的区别是什么
    （1）$router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等
    （2）$route 是路由信息对象||跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，包含path,params,hash,query,fullPath,matched,name等路由信息参数
17. 组件中 data 为什么是函数
    （1）因为组件是用来复用的，JS 里对象是引用关系，这样作用域没有隔离，而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题
18.vue 使用 nextTick 的方法
    this.$nextTick()将回调延迟到下次 DOM 更新循环之后执行。
    在修改数据之后立即使用它，然后等待 DOM 更新。
    它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上；
    vue用异步队列的方式来控制 DOM 更新和 vue.nextTick(callBack) 回调先后执行
    案例1
    mounted() {
      console.log(333,this.$refs['hello']);
      this.$nextTick(() => {       console.log(444,this.$refs['hello']);    });
    },
    created() {
      console.log(111，this.$refs['hello']);
      this.$nextTick(() => { console.log(222,this.$refs['hello']);});
    }
    案例2
    <div>{{value}}</div>
    data:{  return {  value: 'Hello World ~'   }   },
    methods: {
        get() {
            this.value = '你好啊';
            console.log(this.$refs['hello'].innerText);
            this.$nextTick(() => {   console.log(this.$refs['hello'].innerText); });
        }
     }
    microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕
19.Vue2 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？
    //vue2中属性的添加分为，响应式属性
    var vm = new Vue({ data:{ a:1} })  // 初始化的 vm.a  是响应式的
    vm.b = 2   // 添加的  vm.b是非响应式的
    Vue.set(vm.someObject, 'b', 2)// 或 this.$set(this.someObject,'b',2) //添加 响应式属性

    受现代 ES5 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。
    但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？
   
    我们阅读以上源码可知，vm.$set 的实现原理是：
        如果目标是数组，直接使用数组的 splice 方法触发相应式；
        如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用defineReactive 方法进行响应式处理
        （defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）
20.服务端渲染 SSR 《Vue SSR 踩坑之旅》
    SSR：vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。
    （1）服务端渲染的优点：
        更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；
            而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；
        更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；
            SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；
    （2) 服务端渲染的缺点：
        更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；
            并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；
        更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，
            因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。
21.Vue 是如何实现数据双向绑定的
    输入框内容变化时，Data 中的数据同步变化。即 View => Data 的变化。 Data 中的数据变化时，文本节点的内容同步变化。即 Data => View 的变化。
    其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。
    Vue 主要通过以下 4 个步骤来实现数据双向绑定的：
    实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。
    实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。
    实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。
    实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。
    以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章《0 到 1 掌握：Vue 核心之数据双向绑定》，有进行详细的讲解、以及代码 demo 示例。
22.虚拟 DOM 的实现原理主要包括以下 3 部分：
    用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
    diff 算法 — 比较两棵虚拟 DOM 树的差异；
    pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。
    
22.Vue之混入和混淆：https://blog.csdn.net/qq_38912284/article/details/103574048
23.vue-i18n中的$t用法:https://blog.csdn.net/weixin_38761920/article/details/116308619
—————————————————————————————————————————————————————————————————————————————— vue页面加载过慢解决 ——————————————————————————————————————————————————
vue页面加载过慢解决
（1）代码层面的优化
    v-if 和 v-show 区分使用场景
    computed 和 watch 区分使用场景
    v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
    事件的销毁  beforeDestroy(){  window.removeEventListener("scroll",this.handleFun)}  //正确添加事件： window.addEventListener("scroll",this.handleFun)
    图片资源懒加载插件（vu-loazyload）
    路由懒加载  component: resolve=>require(['@/components/HelloWorld'],resolve)
    
    第三方插件的按需引入
    优化无限（插件：vue-virtual-scroll-list   https://github.com/jsj228/myself/blob/master/vue%E4%BC%98%E5%8C%96%E6%97%A0%E9%99%90%E5%88%97%E8%A1%A8%E6%80%A7%E8%83%BD）
    长列表性能优化 (懒加载、分页、滚动节流减少服务器压力、Object.freeze冻结对象)  https://blog.csdn.net/weixin_46396187/article/details/107928838
    服务端渲染 SSR or 预渲染 （beforCreate 和 created ajax中请求html片段）
（2）Webpack 层面的优化
    Webpack 对图片进行压缩
    减少 ES6 转为 ES5 的冗余代码
    提取公共代码
    模板预编译
    提取组件的 CSS
    优化 SourceMap
    构建结果输出分析
    Vue 项目的编译优化
（3）基础的 Web 技术的优化
    开启 gzip 压缩
    浏览器缓存
    CDN 的使用
    使用 Chrome Performance 查找性能瓶颈
一、vue-router路由懒加载
 1、方法一
    export default new Router({
      routes: [
        { path: '/',component: resolve=>require(['@/components/HelloWorld'],resolve)},
        { path: '/B_page',component:require('@/components/B_page').default}
        ]
    })
 2、方法二
    export default new Router({
      routes: [
            { path: '/A_page',  component:()=>import('@/components/A_page') },//A_page 默认加载的组件
            { path: '/B_page',component:require('@/components/B_page').default},
        ]
    })
 3、webpack独有的require.ensure技术，也可以实现按需加载;    
    懒加载是当路由被访问的时候才加载对应组件，而不是在首页就全部加载，以此来提高首页反应速度。
    说明: require.ensure在需要的时候才下载依赖的模块，当参数指定的模块都下载下来了（下载下来的模块还没执行），便执行参数指定的回调函数。require.ensure会创建一个chunk，
    且可以指定该chunk的名称，如果这个chunk名已经存在了，则将本次依赖的模块合并到已经存在的chunk中，最后这个chunk在webpack构建的时候会单独生成一个文件。
    语法: require.ensure(dependencies: String[], callback: function([url]),errorCallback: function(err), [chunkName: String]) 
          dependencies: 依赖的模块数组   
          callback: 成功回调，该函数调用时会传一个require参数     
          errorCallback:错误回调   
          chunkName: 特定模块名，用于构建时生成文件时命名使用， 多个路由指定相同的chunkName，会合并打包成一个js文件。
    import Vue from 'vue'
    import Router from 'vue-router'
    Vue.use(Router) 
    export default new Router({
      routes: [
        {
          path: '/index',
          name: 'Index',
          component: resolve=>require.ensure (['@/components/HelloWorld'],"home")
        },
        {
          path: '/home',
          name: 'home',
          component: resolve=>require.ensure (['@/components/home'],"home")
        }
      ]
    })
    注意点：require.ensure的模块只会被下载下来，不会被执行，只有在回调函数使用require(模块名)后，这个模块才会被执行。
    webpack.base.conf.js修改：https://blog.csdn.net/LSL3521/article/details/105227330
二、打包优化——工程文件打包的时候不生成.map文件
    npm run build编译之后，我们查看编译生成的文件，发现有很多.map文件，这些文件占了不小的空间。
    .map文件的作用是帮助编译后的代码调试，但是我们上线的代码已经调试完成，所以上线时可以不生成.map文件。
    修改配置文件如下即可：productionSourceMap : false 
三、切换多入口模式
    在vue项目中，我们一般使用vue-cli脚手架搭建单页面的web工程。
    main.js是整个单页面应用唯一的入口文件
    在大型项目中，单一入口无法满足项目需要，原因有以下两方面：
    （1）单一入口无法拆分按模块独立部署，不够灵活
    （2）单一入口负载过重，业务模块较多时，点击系统导航菜单频繁切换业务模块，在IE浏览器中，浏览器内存持续上涨，达到 1.5G以上卡顿，浏览器容易崩溃。
    基于以上两点原因，大型项目可以采用多入口的模式，好处有以下两点：
    （1）满足页面需要分开部署的场景            （2）解决了页面卡顿和内存上涨问题
    配置方式参考我的单独讲解多入口配置的博文
四、使用字体图标代替切图
    字体图标的优势:
    （1）字体图标任意缩放不会失真
    （2）在项目中导入后，以css样式引用，相较于传统的图片大大减少请求数量，优化性能
    （3）修改方便，如需要切换主题色可由css控制，避免视觉反复切图的工作量
    在线生成工具: https://icomoon.io/app/#/select
五、使用雪碧图
    雪碧图的优点:
     1.将多张图片合并到一张图片中，可以减小图片的总大小。
     2.将多张图片合并成一张图片后，下载全部所需的资源，只需一次请求。可以减小建立连接的消耗。
六、提取公共样式和方法
    1.复用的样式应当提取到公共的样式表中复用
    2.公共的方法应当提取到公共的js中复用
    3.表单验证的提取    
七、控件销毁
    1.页面切换释放:
    使用的C++控件应当及时销毁
    2. $destroy
    完全销毁一个实例,清理它与其它实例的连接，解绑它的全部指令及事件监听器。
    const testDestroy = new Vue({
        el:'#app',
        data()=>{
            return {
            MsgNotifyParams:{}
        },
        template: "<App :MsgNotifyParams="MsgNotifyParams" /> ",
        compoenents:{App}
    })
    //在即将离开当前页面(刷新或关闭)时执行
    window.onbeforeunload = function (e){
        window.testDestroy.$destroy()
    }
八、销毁 定时器、echarts、事件
    路由离开及时销毁定时器 
    created(){
        this.timer=setInterval(this.refresh,2000);
        this.timerLine=setTimeout(this.refresh,2000);
        addEventListener('touchmove',this.touchmove,false);
        addEventListener("scroll",this.handleFun,false);
    },
    berforeDestory(){
            let _this=this;
        //清空 定时器
            _this.timer&& clearInterval(_this.timer);
            
            _this.timerLine && clearTimeout(_this.timerLine);
            _this.timerPie && clearTimeout(_this.timerPie);
            _this.timerBar && clearTimeout(_this.timerBar);
        //页面切换时清空echarts
            myChartLine.clear();
            myChartPie.clear();
            myChartBar.clear();
        //销毁事件 添加事件： //第三个参数false，为true则忽略事件内部的preventDefault()
            removeEventListener("touchmove",this.touchmove,false)  
            removeEventListener("scroll",this.handleFun,false)  
    }
九、路由离开及时解绑事件:   vm.$off()
十、vue中使用keep-alive
    vue2.0提供了一个keep-alive组件，用来缓存组件,避免多次加载相应的组件,减少性能消耗，  <keep-alive>    <component><!-- 组件将被缓存 --></component>    </keep-alive>
    一般结合路由和动态组件一起使用，用于缓存组件；
    提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
    对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。  
十一、代码层面的优化
    1、v-show，v-if 用哪个？
        （1）只要涉及到权限相关的展示无疑要用 v-if
        （2）在没有权限限制时根据用户点击的频次选择，频繁切换的使用 v-show，不频繁切换的使用 v-if（减少页面中 dom 数量）
    2、不要在模板里面写过多的表达式与判断
        v-if="isShow && isAdmin && (a || b)"，这种表达式虽说可以识别，但是不是长久之计，当看着不舒服时，适当的写到 methods 和 computed 里面封装成一个方法，这样的好处是方便我们在多处判断相同的表达式，其他权限相同的元素再判断展示的时候调用同一个方法即可。
    3、循环调用子组件时添加 key
      key 可以唯一标识一个循环个体，可以使用例如 item.id 作为 key，
      假如数组数据是这样的 ['a' , 'b', 'c', 'a'],使用 :key="item" 显然没有意义，
      更好的办法就是在循环的时候 (item, index) in arr，然后 :key="index"来确保key 的唯一性。不设置key值时vue会抛出警告。
    4、遵守编码规范
        语义化标签，避免乱嵌套，合理命名属性,使用高效简洁的css选择器等等
    5、合理利用vue生命周期
        减少在created生命周期中做ajax请求,而是放在mounted生命周期中,以不阻塞页面生成dom
十二、iframe的内存释放
    相关资料称IE在iframe元素的回收方面存在着bug，需要手动将其释放以避免内存泄漏
    释放方法：手动将iframe指向置空 
    export defaylt {
        name: "windowInspectionRecord",
        methods:{
            clearIframe(){
                var iframe = document.getElementById('windowiframe');
                if(iframe) {
                    iframe.src = "about:blank";
                    try{
                        iframe.document.write('');
                        ifrane.document.clear();
                    }catch(e){}
                    iframe.parentNode.removeChild(iframe);
                }
            }
        },
        beforeRouteLeave ( to,from,next ){
            this.clearIframe()
            next()
        }
    }
